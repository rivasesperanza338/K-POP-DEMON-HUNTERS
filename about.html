<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Simple Obby — Clean Platformer</title>
<style>
  :root{--bg:#87ceeb;--ground:#2e8b57;--panel:rgba(0,0,0,0.45)}
  body{margin:0;display:flex;align-items:center;justify-content:center;height:100vh;background:linear-gradient(#cbe7ff,#87ceeb);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:#111}
  #container{width:980px;max-width:98vw;background:white;border-radius:12px;overflow:hidden;box-shadow:0 10px 40px rgba(0,0,0,0.15)}
  header{padding:12px 18px;background:linear-gradient(90deg,#ffffffaa,#ffffffcc);display:flex;justify-content:space-between;align-items:center}
  header h1{margin:0;font-size:18px}
  #gameArea{position:relative;background:linear-gradient(#87ceeb,#67b7ff);}
  canvas{display:block;width:100%;height:auto;background:transparent;outline:none}
  #hud{position:absolute;left:12px;top:12px;background:var(--panel);color:#fff;padding:8px 12px;border-radius:8px;font-weight:600}
  #controls{position:absolute;right:12px;top:12px;background:var(--panel);color:#fff;padding:8px 12px;border-radius:8px;font-size:13px}
  footer{padding:10px 14px;background:#f7f7f7;font-size:13px;color:#333;display:flex;justify-content:space-between}
  .btn{background:#0b84ff;color:#fff;padding:6px 10px;border-radius:6px;border:none;cursor:pointer}
  .small{font-size:12px;color:#666}
  @media (max-width:600px){header h1{font-size:14px}}
</style>
</head>
<body>
<div id="container">
  <header>
    <h1>Simple Obby — Clean Platformer</h1>
    <div><button id="restartBtn" class="btn">Restart</button></div>
  </header>
  <div id="gameArea">
    <canvas id="gameCanvas" width="960" height="540" tabindex="0"></canvas>
    <div id="hud">Stage: <span id="stage">1</span> &nbsp;|&nbsp; Lives: <span id="lives">3</span> &nbsp;|&nbsp; Time: <span id="timer">0.00</span>s</div>
    <div id="controls">Use ← → to move, ↑ or Space to jump</div>
  </div>
  <footer>
    <div>Simple Obby demo — HTML/CSS/JS</div>
    <div class="small">Features: Clean platformer with moving platforms and stage progression</div>
  </footer>
</div>

<script>
// Simple Obby - Clean platformer without boosters, disappearing planks, lava, or enemies

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const stageLabel = document.getElementById('stage');
const livesLabel = document.getElementById('lives');
const timerLabel = document.getElementById('timer');
const restartBtn = document.getElementById('restartBtn');

const W = canvas.width, H = canvas.height;
canvas.setAttribute('tabindex','0');
canvas.addEventListener('click', ()=> canvas.focus());

// Input
const keys = {};
document.addEventListener('keydown', e => {
  if (["ArrowLeft","ArrowRight","ArrowUp","Space","KeyA","KeyD"].includes(e.code)) e.preventDefault();
  keys[e.code] = true;
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

// Landing sound (simple WebAudio blip)
let landCtx = null;
function ensureLandAudio(){
  if(landCtx) return;
  try{ landCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){ landCtx = null; }
}
function playLand(){
  try{
    ensureLandAudio();
    if(!landCtx) return;
    const o = landCtx.createOscillator();
    const g = landCtx.createGain();
    o.type = 'sine'; o.frequency.value = 320;
    g.gain.setValueAtTime(0.18, landCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.0001, landCtx.currentTime + 0.12);
    o.connect(g); g.connect(landCtx.destination);
    o.start(); o.stop(landCtx.currentTime + 0.12);
  }catch(e){ /* ignore audio errors */ }
}

// Spike damage sound
function playSpikeDamage(){
  try{
    ensureLandAudio();
    if(!landCtx) return;
    const o = landCtx.createOscillator();
    const g = landCtx.createGain();
    o.type = 'sawtooth'; o.frequency.value = 150;
    g.gain.setValueAtTime(0.25, landCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.0001, landCtx.currentTime + 0.3);
    o.connect(g); g.connect(landCtx.destination);
    o.start(); o.stop(landCtx.currentTime + 0.3);
  }catch(e){ /* ignore audio errors */ }
}

// Poop collision sound
function playPoopSound(){
  try{
    ensureLandAudio();
    if(!landCtx) return;
    // Create a "squishy" sound
    const o = landCtx.createOscillator();
    const g = landCtx.createGain();
    o.type = 'sawtooth'; 
    o.frequency.value = 80;
    o.frequency.exponentialRampToValueAtTime(60, landCtx.currentTime + 0.4);
    
    g.gain.setValueAtTime(0.3, landCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.0001, landCtx.currentTime + 0.5);
    o.connect(g); g.connect(landCtx.destination);
    o.start(); o.stop(landCtx.currentTime + 0.5);
  }catch(e){ /* ignore audio errors */ }
}

// Stage complete sound
function playStageComplete(){
  try{
    ensureLandAudio();
    if(!landCtx) return;
    // Play a cheerful ascending tone
    const o1 = landCtx.createOscillator();
    const g1 = landCtx.createGain();
    o1.type = 'sine'; o1.frequency.value = 523.25; // C5
    g1.gain.setValueAtTime(0.2, landCtx.currentTime);
    g1.gain.exponentialRampToValueAtTime(0.0001, landCtx.currentTime + 0.3);
    o1.connect(g1); g1.connect(landCtx.destination);
    o1.start(); o1.stop(landCtx.currentTime + 0.3);
    
    setTimeout(() => {
      const o2 = landCtx.createOscillator();
      const g2 = landCtx.createGain();
      o2.type = 'sine'; o2.frequency.value = 659.25; // E5
      g2.gain.setValueAtTime(0.2, landCtx.currentTime);
      g2.gain.exponentialRampToValueAtTime(0.0001, landCtx.currentTime + 0.3);
      o2.connect(g2); g2.connect(landCtx.destination);
      o2.start(); o2.stop(landCtx.currentTime + 0.3);
    }, 100);
    
    setTimeout(() => {
      const o3 = landCtx.createOscillator();
      const g3 = landCtx.createGain();
      o3.type = 'sine'; o3.frequency.value = 783.99; // G5
      g3.gain.setValueAtTime(0.2, landCtx.currentTime);
      g3.gain.exponentialRampToValueAtTime(0.0001, landCtx.currentTime + 0.5);
      o3.connect(g3); g3.connect(landCtx.destination);
      o3.start(); o3.stop(landCtx.currentTime + 0.5);
    }, 200);
  }catch(e){ /* ignore audio errors */ }
}

// Player object - Human character
const player = {
  x: 80, y: 420, w: 30, h: 50,
  vx: 0, vy: 0,
  speed: 3.2,
  jumpForce: 13,
  gravity: 0.5,
  onGround: false,
  color: '#ffce54',
  lives: 3,
  facingRight: true,
  // Animation properties
  legAngle: 0,
  armAngle: 0,
  isMoving: false,
  // Poop properties
  stinky: false,
  stinkTimer: 0,
  stinkParticles: []
};

// World objects - Platforms, spikes, and poop
let platforms = [];
let spikes = [];
let poops = [];
let fog = { offset:0 };
let stage = 1;
let checkpoint = { x:80, y:420 };
let stageStartTime = performance.now();

// Background system - different design for each stage
const backgrounds = [
  // Stage 1: Classic Sky
  {
    name: "Classic Sky",
    skyGradient: ['#9be6ff', '#67b7ff'],
    groundColor: '#66b07a',
    groundShapes: [
      { type: 'arc', x: 160, y: 520, radius: 220, start: Math.PI, end: 0 },
      { type: 'arc', x: 480, y: 540, radius: 300, start: Math.PI, end: 0 }
    ],
    clouds: true,
    sun: true
  },
  // Stage 2: Sunset
  {
    name: "Sunset",
    skyGradient: ['#ff9a8b', '#ff6b6b'],
    groundColor: '#8b4513',
    groundShapes: [
      { type: 'arc', x: 200, y: 520, radius: 180, start: Math.PI, end: 0 },
      { type: 'arc', x: 520, y: 540, radius: 250, start: Math.PI, end: 0 },
      { type: 'rect', x: 700, y: 500, w: 200, h: 40 }
    ],
    clouds: true,
    sun: false,
    sunset: true
  },
  // Stage 3: Night
  {
    name: "Night",
    skyGradient: ['#1e3c72', '#2a5298'],
    groundColor: '#2c3e50',
    groundShapes: [
      { type: 'arc', x: 120, y: 520, radius: 200, start: Math.PI, end: 0 },
      { type: 'arc', x: 440, y: 540, radius: 280, start: Math.PI, end: 0 },
      { type: 'arc', x: 760, y: 530, radius: 150, start: Math.PI, end: 0 }
    ],
    clouds: false,
    sun: false,
    stars: true,
    moon: true
  },
  // Stage 4: Forest
  {
    name: "Forest",
    skyGradient: ['#87ceeb', '#98fb98'],
    groundColor: '#228b22',
    groundShapes: [
      { type: 'arc', x: 100, y: 520, radius: 180, start: Math.PI, end: 0 },
      { type: 'arc', x: 350, y: 540, radius: 220, start: Math.PI, end: 0 },
      { type: 'arc', x: 600, y: 530, radius: 190, start: Math.PI, end: 0 },
      { type: 'arc', x: 850, y: 520, radius: 160, start: Math.PI, end: 0 }
    ],
    clouds: true,
    sun: true,
    trees: true
  },
  // Stage 5: Desert
  {
    name: "Desert",
    skyGradient: ['#ffd89b', '#ffb347'],
    groundColor: '#d2b48c',
    groundShapes: [
      { type: 'arc', x: 300, y: 520, radius: 250, start: Math.PI, end: 0 },
      { type: 'arc', x: 650, y: 540, radius: 200, start: Math.PI, end: 0 }
    ],
    clouds: false,
    sun: true,
    dunes: true
  },
  // Stage 6+: Random combination
  {
    name: "Mystery",
    skyGradient: ['#' + Math.floor(Math.random()*16777215).toString(16), '#' + Math.floor(Math.random()*16777215).toString(16)],
    groundColor: '#' + Math.floor(Math.random()*16777215).toString(16),
    groundShapes: [
      { type: 'arc', x: 100 + Math.random()*200, y: 520, radius: 150 + Math.random()*100, start: Math.PI, end: 0 },
      { type: 'arc', x: 400 + Math.random()*200, y: 540, radius: 180 + Math.random()*120, start: Math.PI, end: 0 },
      { type: 'arc', x: 700 + Math.random()*200, y: 530, radius: 130 + Math.random()*90, start: Math.PI, end: 0 }
    ],
    clouds: Math.random() > 0.5,
    sun: Math.random() > 0.5,
    stars: Math.random() > 0.7,
    special: true
  }
];

let currentBackground = backgrounds[0];

// Calmer background ambient audio
let audioCtx = null, bgOsc1 = null, bgOsc2 = null, bgGain = null, bgFilter = null;
function startAmbient(){
  if(audioCtx) return;
  try{
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    // Create a low-pass filter for smoother sound
    bgFilter = audioCtx.createBiquadFilter();
    bgFilter.type = 'lowpass';
    bgFilter.frequency.value = 800; // Lower frequency for calmer sound
    bgFilter.Q.value = 0.7; // Gentle resonance
    
    bgGain = audioCtx.createGain(); 
    bgGain.gain.value = 0.03; // Lower volume for calmer sound
    
    // First oscillator - deep, calming bass
    bgOsc1 = audioCtx.createOscillator(); 
    bgOsc1.type = 'sine'; // Smoother wave type
    bgOsc1.frequency.value = 82.41; // Low E note - very calming
    
    // Second oscillator - gentle harmonics
    bgOsc2 = audioCtx.createOscillator(); 
    bgOsc2.type = 'sine'; 
    bgOsc2.frequency.value = 164.81; // E one octave higher
    
    // Connect everything
    const mix = audioCtx.createGain(); 
    mix.gain.value = 0.8; 
    
    bgOsc1.connect(mix);
    bgOsc2.connect(mix);
    mix.connect(bgFilter);
    bgFilter.connect(bgGain);
    bgGain.connect(audioCtx.destination);
    
    // Start oscillators
    bgOsc1.start(); 
    bgOsc2.start();
    
    // Very slow, gentle frequency variations for calm atmosphere
    setInterval(()=>{
      if(!audioCtx) return;
      const now = audioCtx.currentTime;
      
      // Very subtle frequency changes
      bgOsc1.frequency.setTargetAtTime(82.41 + Math.sin(performance.now() / 8000) * 2, now, 4.0);
      bgOsc2.frequency.setTargetAtTime(164.81 + Math.sin(performance.now() / 6000) * 3, now, 4.0);
      
      // Gentle volume pulsation
      bgGain.gain.setTargetAtTime(0.03 + Math.sin(performance.now() / 5000) * 0.01, now, 3.0);
    }, 3000); // Slower updates for calmer feel
  }catch(e){ 
    audioCtx = null; 
    console.log("Audio not supported:", e);
  }
}

// call startAmbient on first user interaction
window.addEventListener('pointerdown', ()=>{ 
  try{ 
    startAmbient(); 
    if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); 
  }catch(e){} 
}, { once:true });

function createStage(n){
  platforms = [];
  spikes = [];
  poops = [];

  // Set background based on stage (cycle through available backgrounds)
  const bgIndex = (n - 1) % backgrounds.length;
  currentBackground = backgrounds[bgIndex];

  // floor
  platforms.push({ x:0, y: 500, w: W, h: 40, type:'static' });
  platforms.push({ x:40, y:420, w:120, h:14, type:'static' });

  // Create spikes on the ground
  createSpikesOnGround();
  
  // Create poop on the ground
  createPoopOnGround();

  const count = 6 + Math.floor(n * 1.3);
  let x = 200;
  for(let i=0;i<count;i++){
    const r = Math.random();
    if(r < 0.7){
      // Static platforms (70% chance)
      const y = 180 + Math.random()*240;
      platforms.push({ x:x, y:y, w: 110, h:14, type:'static' });
    } else {
      // Moving platforms (30% chance)
      const y = 180 + Math.random()*220;
      const range = 80 + Math.random()*200 + n*6;
      const speed = 0.4 + Math.random()*0.9 + n*0.06;
      platforms.push({ x:x, y:y, w:90, h:14, type:'moving', vx: speed, baseX: x, range });
    }
    x += 160 + Math.random()*140;
  }

  platforms.push({ 
    x: Math.min(W-80, x), 
    y: 420, 
    w: 64, 
    h: 30, 
    type:'goal' 
  });
  
  checkpoint = { x: 80, y: 420 };
  stageStartTime = performance.now();
}

function createSpikesOnGround() {
  // Add spikes along the ground at various positions
  const spikeWidth = 20;
  const spikeHeight = 15;
  const groundY = 500; // Y position of the ground
  
  // Create spikes in dangerous areas (not near the start)
  for (let x = 300; x < W - 100; x += 40 + Math.random() * 60) {
    // Sometimes skip a spike to create gaps
    if (Math.random() > 0.3) {
      spikes.push({
        x: x,
        y: groundY - spikeHeight,
        w: spikeWidth,
        h: spikeHeight
      });
    }
  }
  
  // Add some spikes under challenging platform sections
  for (let i = 0; i < 4 + stage; i++) {
    const x = 400 + Math.random() * (W - 600);
    spikes.push({
      x: x,
      y: groundY - spikeHeight,
      w: spikeWidth,
      h: spikeHeight
    });
  }
}

function createPoopOnGround() {
  // Add poop along the ground in tricky spots
  const poopWidth = 25;
  const poopHeight = 15;
  const groundY = 500; // Y position of the ground
  
  // Create poop in strategic locations (near platform edges, etc.)
  for (let i = 0; i < 3 + stage; i++) {
    // Place poop in challenging positions
    const x = 350 + Math.random() * (W - 500);
    poops.push({
      x: x,
      y: groundY - poopHeight,
      w: poopWidth,
      h: poopHeight
    });
  }
  
  // Add some poop directly under platform gaps
  for (const platform of platforms) {
    if (platform.type === 'static' && Math.random() > 0.7) {
      poops.push({
        x: platform.x + platform.w/2 - poopWidth/2,
        y: groundY - poopHeight,
        w: poopWidth,
        h: poopHeight
      });
    }
  }
}

function drawSpikes() {
  for (const spike of spikes) {
    // Draw spike base
    ctx.fillStyle = '#8b2d2d';
    ctx.fillRect(spike.x, spike.y, spike.w, spike.h);
    
    // Draw spike triangles
    ctx.fillStyle = '#ff5a5a';
    
    // Draw multiple triangle points along the spike
    const numPoints = 3;
    const pointWidth = spike.w / numPoints;
    
    for (let i = 0; i < numPoints; i++) {
      const pointX = spike.x + (i * pointWidth) + (pointWidth / 2);
      
      ctx.beginPath();
      ctx.moveTo(pointX, spike.y + spike.h);
      ctx.lineTo(pointX - pointWidth/2, spike.y);
      ctx.lineTo(pointX + pointWidth/2, spike.y);
      ctx.closePath();
      ctx.fill();
    }
  }
}

function drawPoop() {
  for (const poop of poops) {
    // Draw poop base (brown)
    ctx.fillStyle = '#8B4513'; // Brown color
    ctx.beginPath();
    ctx.ellipse(poop.x + poop.w/2, poop.y + poop.h/2, poop.w/2, poop.h/2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw poop texture (darker spots)
    ctx.fillStyle = '#654321';
    for (let i = 0; i < 3; i++) {
      const spotX = poop.x + 5 + Math.random() * (poop.w - 10);
      const spotY = poop.y + 3 + Math.random() * (poop.h - 6);
      const spotSize = 2 + Math.random() * 3;
      ctx.beginPath();
      ctx.arc(spotX, spotY, spotSize, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Draw stink lines if player is stinky nearby
    if (player.stinky) {
      const distance = Math.sqrt(
        Math.pow(player.x - poop.x, 2) + Math.pow(player.y - poop.y, 2)
      );
      if (distance < 150) {
        ctx.strokeStyle = 'rgba(139, 69, 19, 0.5)';
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(poop.x + poop.w/2, poop.y);
        ctx.lineTo(poop.x + poop.w/2, poop.y - 30);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }
  }
}

function drawStinkEffect() {
  if (!player.stinky) return;
  
  // Draw stink lines around player
  ctx.strokeStyle = 'rgba(139, 69, 19, 0.7)';
  ctx.setLineDash([3, 3]);
  ctx.lineWidth = 2;
  
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2;
    const length = 20 + Math.sin(performance.now() / 200 + i) * 10;
    
    ctx.beginPath();
    ctx.moveTo(player.x + player.w/2, player.y + player.h/2);
    ctx.lineTo(
      player.x + player.w/2 + Math.cos(angle) * length,
      player.y + player.h/2 + Math.sin(angle) * length
    );
    ctx.stroke();
  }
  
  ctx.setLineDash([]);
  
  // Draw stink particles
  for (let i = player.stinkParticles.length - 1; i >= 0; i--) {
    const particle = player.stinkParticles[i];
    
    ctx.fillStyle = `rgba(139, 69, 19, ${particle.alpha})`;
    ctx.beginPath();
    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
    ctx.fill();
    
    // Update particle
    particle.x += particle.vx;
    particle.y += particle.vy;
    particle.vy += 0.05; // Gravity
    particle.alpha -= 0.02;
    particle.life--;
    
    // Remove dead particles
    if (particle.life <= 0 || particle.alpha <= 0) {
      player.stinkParticles.splice(i, 1);
    }
  }
  
  // Add new stink particles occasionally
  if (Math.random() < 0.3) {
    player.stinkParticles.push({
      x: player.x + player.w/2 + (Math.random() - 0.5) * 20,
      y: player.y + player.h/2,
      vx: (Math.random() - 0.5) * 2,
      vy: -Math.random() * 3,
      size: 2 + Math.random() * 3,
      alpha: 0.7,
      life: 30
    });
  }
}

function drawBackground() {
  const bg = currentBackground;
  
  // Draw sky gradient
  const gradient = ctx.createLinearGradient(0, 0, 0, H);
  gradient.addColorStop(0, bg.skyGradient[0]);
  gradient.addColorStop(1, bg.skyGradient[1]);
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, W, H);
  
  // Draw ground
  ctx.fillStyle = bg.groundColor;
  for (const shape of bg.groundShapes) {
    if (shape.type === 'arc') {
      ctx.beginPath();
      ctx.arc(shape.x, shape.y, shape.radius, shape.start, shape.end);
      ctx.fill();
    } else if (shape.type === 'rect') {
      ctx.fillRect(shape.x, shape.y, shape.w, shape.h);
    }
  }
  
  // Draw sun if enabled
  if (bg.sun) {
    ctx.fillStyle = '#ffeb3b';
    ctx.beginPath();
    ctx.arc(800, 80, 40, 0, Math.PI * 2);
    ctx.fill();
    
    // Sun rays
    ctx.strokeStyle = '#ffeb3b';
    ctx.lineWidth = 3;
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      ctx.beginPath();
      ctx.moveTo(800 + Math.cos(angle) * 45, 80 + Math.sin(angle) * 45);
      ctx.lineTo(800 + Math.cos(angle) * 65, 80 + Math.sin(angle) * 65);
      ctx.stroke();
    }
  }
  
  // Draw moon if enabled
  if (bg.moon) {
    ctx.fillStyle = '#f5f5f5';
    ctx.beginPath();
    ctx.arc(800, 80, 30, 0, Math.PI * 2);
    ctx.fill();
    
    // Moon craters
    ctx.fillStyle = '#e0e0e0';
    ctx.beginPath();
    ctx.arc(790, 70, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(810, 90, 7, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Draw stars if enabled
  if (bg.stars) {
    ctx.fillStyle = '#ffffff';
    for (let i = 0; i < 50; i++) {
      const x = Math.random() * W;
      const y = Math.random() * 300;
      const size = Math.random() * 2 + 1;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  // Draw clouds if enabled
  if (bg.clouds) {
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    for (let i = 0; i < 5; i++) {
      const x = 100 + i * 180 + Math.sin(performance.now() / 5000 + i) * 50;
      const y = 80 + i * 30;
      drawCloud(x, y);
    }
  }
  
  // Draw trees if enabled
  if (bg.trees) {
    ctx.fillStyle = '#8b4513'; // Tree trunk color
    for (let i = 0; i < 6; i++) {
      const x = 150 + i * 150;
      // Tree trunk
      ctx.fillRect(x, 450, 15, 50);
      // Tree leaves
      ctx.fillStyle = '#228b22';
      ctx.beginPath();
      ctx.arc(x + 7, 440, 25, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.fillStyle = bg.groundColor; // Reset to ground color
  }
  
  // Draw sunset if enabled
  if (bg.sunset) {
    const sunsetGradient = ctx.createRadialGradient(800, 80, 0, 800, 80, 200);
    sunsetGradient.addColorStop(0, 'rgba(255, 165, 0, 0.6)');
    sunsetGradient.addColorStop(1, 'rgba(255, 165, 0, 0)');
    ctx.fillStyle = sunsetGradient;
    ctx.beginPath();
    ctx.arc(800, 80, 200, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Draw special effects for random backgrounds
  if (bg.special) {
    // Add some random floating shapes
    for (let i = 0; i < 10; i++) {
      const x = Math.random() * W;
      const y = Math.random() * 200;
      const size = Math.random() * 20 + 10;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      
      if (Math.random() > 0.5) {
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.fillRect(x, y, size, size);
      }
    }
  }
}

function drawCloud(x, y) {
  ctx.beginPath();
  ctx.arc(x, y, 20, 0, Math.PI * 2);
  ctx.arc(x + 15, y - 10, 15, 0, Math.PI * 2);
  ctx.arc(x + 30, y, 20, 0, Math.PI * 2);
  ctx.arc(x + 15, y + 10, 15, 0, Math.PI * 2);
  ctx.fill();
}

function rectsOverlap(a,b){ 
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h); 
}

function update(dt){
  let left = keys['ArrowLeft'] || keys['KeyA'];
  let right = keys['ArrowRight'] || keys['KeyD'];
  
  // Update player facing direction
  if (left) player.facingRight = false;
  if (right) player.facingRight = true;
  
  // Update movement animation
  player.isMoving = left || right;
  if (player.isMoving) {
    player.legAngle = Math.sin(performance.now() / 150) * 0.5;
    player.armAngle = Math.sin(performance.now() / 150) * 0.4;
  } else {
    player.legAngle = 0;
    player.armAngle = 0;
  }
  
  // Update stink timer
  if (player.stinky) {
    player.stinkTimer -= dt;
    if (player.stinkTimer <= 0) {
      player.stinky = false;
      player.stinkParticles = [];
    }
  }
  
  if(left) player.vx = -player.speed;
  else if(right) player.vx = player.speed;
  else player.vx = 0;

  if((keys['ArrowUp'] || keys['Space']) && player.onGround){ 
    player.vy = -player.jumpForce; 
    player.onGround = false; 
  }

  player.vy += player.gravity;
  player.x += player.vx * dt;
  player.y += player.vy * dt;
  player.x = Math.max(0, Math.min(W - player.w, player.x));

  // Update moving platforms
  for(let p of platforms){ 
    if(p.type === 'moving'){ 
      p.x += p.vx * dt; 
      if(p.x > p.baseX + p.range || p.x < p.baseX - p.range) p.vx *= -1; 
    } 
  }

  // Platform collisions
  player.onGround = false;
  for(let p of platforms){
    if(player.vy >= 0 && player.x + player.w > p.x + 2 && player.x < p.x + p.w - 2 && player.y + player.h > p.y && player.y + player.h < p.y + p.h + Math.abs(player.vy) + 2){
      playLand();
      player.y = p.y - player.h; 
      player.vy = 0; 
      player.onGround = true;
      if(p.type === 'goal'){ 
        playStageComplete();
        nextStage(); 
      }
    }
  }

  // Spike collisions
  for(const spike of spikes){
    const spikeRect = { x: spike.x, y: spike.y, w: spike.w, h: spike.h };
    const playerRect = { x: player.x, y: player.y, w: player.w, h: player.h };
    if(rectsOverlap(spikeRect, playerRect)) {
      playSpikeDamage();
      hurtPlayer();
      break; // Only trigger once per frame
    }
  }

  // Poop collisions
  for(const poop of poops){
    const poopRect = { x: poop.x, y: poop.y, w: poop.w, h: poop.h };
    const playerRect = { x: player.x, y: player.y, w: player.w, h: player.h };
    if(rectsOverlap(poopRect, playerRect)) {
      playPoopSound();
      player.stinky = true;
      player.stinkTimer = 300; // 5 seconds of stink
      restartGame();
      break; // Only trigger once per frame
    }
  }

  // Player falls off the bottom of the screen
  if(player.y > H + 120) hurtPlayer();
}

function restartGame() {
  player.lives = 3;
  stage = 1;
  stageLabel.textContent = stage;
  livesLabel.textContent = player.lives;
  createStage(stage);
  respawnToCheckpoint(true);
}

function hurtPlayer(){
  player.lives -= 1; 
  livesLabel.textContent = player.lives;
  if(player.lives <= 0){
    restartGame();
  } else {
    respawnToCheckpoint(false);
  }
}

function respawnToCheckpoint(fullReset){
  player.x = checkpoint.x; 
  player.y = checkpoint.y; 
  player.vx = 0; 
  player.vy = 0; 
  player.onGround = false;
  player.stinky = false;
  player.stinkParticles = [];
  if(fullReset) createStage(stage);
}

function nextStage(){ 
  stage += 1; 
  stageLabel.textContent = stage; 
  createStage(stage); 
  respawnToCheckpoint(false); 
}

// Draw human character function
function drawHumanPlayer() {
  const centerX = player.x + player.w / 2;
  const centerY = player.y + player.h / 2;
  
  // Save context for transformations
  ctx.save();
  
  // Change player color if stinky
  if (player.stinky) {
    ctx.fillStyle = '#8B4513'; // Brown when stinky
  } else {
    ctx.fillStyle = '#3498db'; // Blue shirt when clean
  }
  
  // Draw body (torso)
  ctx.fillRect(player.x + 5, player.y + 10, player.w - 10, 20);
  
  // Draw head
  ctx.fillStyle = player.stinky ? '#a0522d' : '#ffdbac'; // Darker skin when stinky
  ctx.beginPath();
  ctx.arc(centerX, player.y + 10, 8, 0, Math.PI * 2);
  ctx.fill();
  
  // Draw hair
  ctx.fillStyle = player.stinky ? '#5d4037' : '#2c3e50'; // Darker hair when stinky
  ctx.beginPath();
  ctx.arc(centerX, player.y + 8, 9, 0, Math.PI * 2);
  ctx.fill();
  
  // Draw eyes
  ctx.fillStyle = '#2c3e50';
  const eyeOffset = player.facingRight ? 2 : -2;
  ctx.beginPath();
  ctx.arc(centerX - 3 + eyeOffset, player.y + 8, 1.5, 0, Math.PI * 2);
  ctx.arc(centerX + 3 + eyeOffset, player.y + 8, 1.5, 0, Math.PI * 2);
  ctx.fill();
  
  // Draw mouth - make it look disgusted when stinky
  ctx.strokeStyle = '#2c3e50';
  ctx.lineWidth = 1;
  ctx.beginPath();
  if (player.stinky) {
    // Disgusted mouth (curved down)
    ctx.arc(centerX + eyeOffset, player.y + 13, 2, 0.1, Math.PI - 0.1);
  } else {
    // Normal mouth
    ctx.arc(centerX + eyeOffset, player.y + 12, 2, 0, Math.PI);
  }
  ctx.stroke();
  
  // Draw arms with animation
  ctx.fillStyle = player.stinky ? '#8B4513' : '#3498db';
  const armAngle = player.armAngle * (player.facingRight ? 1 : -1);
  
  // Left arm
  ctx.save();
  ctx.translate(player.x + 5, player.y + 20);
  ctx.rotate(armAngle);
  ctx.fillRect(0, 0, 8, 4);
  ctx.restore();
  
  // Right arm
  ctx.save();
  ctx.translate(player.x + player.w - 5, player.y + 20);
  ctx.rotate(-armAngle);
  ctx.fillRect(-8, 0, 8, 4);
  ctx.restore();
  
  // Draw legs with animation
  ctx.fillStyle = player.stinky ? '#5d4037' : '#2c3e50'; // Darker pants when stinky
  const legAngle = player.legAngle * (player.facingRight ? 1 : -1);
  
  // Left leg
  ctx.save();
  ctx.translate(player.x + 8, player.y + 30);
  ctx.rotate(legAngle);
  ctx.fillRect(0, 0, 4, 15);
  ctx.restore();
  
  // Right leg
  ctx.save();
  ctx.translate(player.x + player.w - 8, player.y + 30);
  ctx.rotate(-legAngle);
  ctx.fillRect(-4, 0, 4, 15);
  ctx.restore();
  
  // Restore context
  ctx.restore();
}

function draw(){
  // Draw the dynamic background
  drawBackground();

  drawFog();

  // Draw platforms
  for(let p of platforms){
    if(p.type === 'goal'){
      // Goal platform
      ctx.fillStyle = '#00d153'; 
      ctx.fillRect(p.x, p.y, p.w, p.h);
      ctx.fillStyle = '#008a3a'; 
      ctx.fillRect(p.x, p.y + p.h, p.w, 6);
      
      // Goal text
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 12px Arial';
      ctx.fillText('GOAL', p.x + p.w/2 - 15, p.y + p.h/2 + 4);
    } else {
      // Regular platforms
      ctx.fillStyle = '#7a7a7a';
      ctx.fillRect(p.x, p.y, p.w, p.h);
      ctx.fillStyle = '#5a5a5a'; 
      ctx.fillRect(p.x, p.y + p.h, p.w, 6);
    }
  }

  // Draw spikes
  drawSpikes();
  
  // Draw poop
  drawPoop();

  // Draw human character
  drawHumanPlayer();
  
  // Draw stink effect if player is stinky
  drawStinkEffect();

  // Update timer
  const elapsed = (performance.now() - stageStartTime) / 1000; 
  timerLabel.textContent = elapsed.toFixed(2);
}

function drawFog(){
  fog.offset += 0.15;
  const bands = 4;
  for(let i=0;i<bands;i++){
    const alpha = 0.06 + i*0.02;
    ctx.fillStyle = `rgba(240,248,255,${alpha})`;
    const y = 60 + i*80 + Math.sin((fog.offset + i*10)/12) * 8;
    ctx.beginPath(); 
    ctx.ellipse(
      W/2 + Math.sin((fog.offset + i*30)/20)*40, 
      y, 
      W*0.9, 
      40, 
      0, 
      0, 
      Math.PI*2
    ); 
    ctx.fill();
  }
}

let last = performance.now();
function loop(now){
  const dt = Math.min(2, (now - last)/16.6667); 
  last = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

restartBtn.addEventListener('click', ()=>{ 
  restartGame();
});

window.addEventListener('pointerdown', ()=>{ 
  if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); 
});

try{ canvas.focus(); }catch(e){}

</script>
</body>
</html>
